From d004983824c92bb755c9e89da6b582b7b65e0dee Mon Sep 17 00:00:00 2001
From: Neil Armstrong <narmstrong@baylibre.com>
Date: Wed, 12 Sep 2018 14:26:10 +0000
Subject: [PATCH 1/3] utils: Add CPU SoC information

Add a new line in GUIWindowSystemInfo to display the actual
SoC (System-On-Chip) used on the system, it defaults to N/A
and the test has been updated to also cover it.

Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
---
 xbmc/utils/CPUInfo.cpp               | 2 ++
 xbmc/utils/CPUInfo.h                 | 3 +++
 xbmc/utils/SystemInfo.cpp            | 5 +++++
 xbmc/utils/SystemInfo.h              | 1 +
 xbmc/utils/test/TestCPUInfo.cpp      | 6 ++++++
 xbmc/windows/GUIWindowSystemInfo.cpp | 1 +
 6 files changed, 18 insertions(+)

diff --git a/xbmc/utils/CPUInfo.cpp b/xbmc/utils/CPUInfo.cpp
index cb4658464c4e..24cf8a5e70d3 100644
--- a/xbmc/utils/CPUInfo.cpp
+++ b/xbmc/utils/CPUInfo.cpp
@@ -451,6 +451,8 @@ CCPUInfo::CCPUInfo(void)
   /* Set some default for empty string variables */
   if (m_cpuBogoMips.empty())
     m_cpuBogoMips = "N/A";
+  if (m_cpuSoC.empty())
+    m_cpuSoC = "N/A";
   if (m_cpuHardware.empty())
     m_cpuHardware = "N/A";
   if (m_cpuRevision.empty())
diff --git a/xbmc/utils/CPUInfo.h b/xbmc/utils/CPUInfo.h
index 9cde6c2f4f9f..fa99213d1303 100644
--- a/xbmc/utils/CPUInfo.h
+++ b/xbmc/utils/CPUInfo.h
@@ -54,6 +54,7 @@ struct CoreInfo
   std::string m_strVendor;
   std::string m_strModel;
   std::string m_strBogoMips;
+  std::string m_strSoC;
   std::string m_strHardware;
   std::string m_strRevision;
   std::string m_strSerial;
@@ -72,6 +73,7 @@ class CCPUInfo
   bool getTemperature(CTemperature& temperature);
   std::string& getCPUModel() { return m_cpuModel; }
   std::string& getCPUBogoMips() { return m_cpuBogoMips; }
+  std::string& getCPUSoC() { return m_cpuSoC; }
   std::string& getCPUHardware() { return m_cpuHardware; }
   std::string& getCPURevision() { return m_cpuRevision; }
   std::string& getCPUSerial() { return m_cpuSerial; }
@@ -115,6 +117,7 @@ class CCPUInfo
   XbmcThreads::EndTime m_nextUsedReadTime;
   std::string  m_cpuModel;
   std::string  m_cpuBogoMips;
+  std::string  m_cpuSoC;
   std::string  m_cpuHardware;
   std::string  m_cpuRevision;
   std::string  m_cpuSerial;
diff --git a/xbmc/utils/SystemInfo.cpp b/xbmc/utils/SystemInfo.cpp
index c8bd4e2dff0f..4eb995528f7d 100644
--- a/xbmc/utils/SystemInfo.cpp
+++ b/xbmc/utils/SystemInfo.cpp
@@ -498,6 +498,11 @@ std::string CSysInfo::GetCPUBogoMips()
   return "BogoMips: " + g_cpuInfo.getCPUBogoMips();
 }
 
+std::string CSysInfo::GetCPUSoC()
+{
+  return "SoC: " + g_cpuInfo.getCPUSoC();
+}
+
 std::string CSysInfo::GetCPUHardware()
 {
   return "Hardware: " + g_cpuInfo.getCPUHardware();
diff --git a/xbmc/utils/SystemInfo.h b/xbmc/utils/SystemInfo.h
index bda348af4ed3..bc165de3ccda 100644
--- a/xbmc/utils/SystemInfo.h
+++ b/xbmc/utils/SystemInfo.h
@@ -122,6 +122,7 @@ class CSysInfo : public CInfoLoader, public ISubSettings
   static const std::string& GetKernelCpuFamily(void);
   std::string GetCPUModel();
   std::string GetCPUBogoMips();
+  std::string GetCPUSoC();
   std::string GetCPUHardware();
   std::string GetCPURevision();
   std::string GetCPUSerial();
diff --git a/xbmc/utils/test/TestCPUInfo.cpp b/xbmc/utils/test/TestCPUInfo.cpp
index 821094f51fb8..81e23802e09c 100644
--- a/xbmc/utils/test/TestCPUInfo.cpp
+++ b/xbmc/utils/test/TestCPUInfo.cpp
@@ -83,6 +83,12 @@ TEST(TestCPUInfo, getCPUBogoMips)
   EXPECT_STRNE("", s.c_str());
 }
 
+TEST(TestCPUInfo, getCPUSoC)
+{
+  std::string s = g_cpuInfo.getCPUSoC();
+  EXPECT_STRNE("", s.c_str());
+}
+
 TEST(TestCPUInfo, getCPUHardware)
 {
   std::string s = g_cpuInfo.getCPUHardware();
diff --git a/xbmc/windows/GUIWindowSystemInfo.cpp b/xbmc/windows/GUIWindowSystemInfo.cpp
index 83ab46b3c908..1a49f920063c 100644
--- a/xbmc/windows/GUIWindowSystemInfo.cpp
+++ b/xbmc/windows/GUIWindowSystemInfo.cpp
@@ -147,6 +147,7 @@ void CGUIWindowSystemInfo::FrameMove()
     SET_CONTROL_LABEL(i++, g_sysinfo.GetCPUModel());
 #if defined(__arm__) && defined(TARGET_LINUX)
     SET_CONTROL_LABEL(i++, g_sysinfo.GetCPUBogoMips());
+    SET_CONTROL_LABEL(i++, g_sysinfo.GetCPUSoC());
     SET_CONTROL_LABEL(i++, g_sysinfo.GetCPUHardware());
     SET_CONTROL_LABEL(i++, g_sysinfo.GetCPURevision());
     SET_CONTROL_LABEL(i++, g_sysinfo.GetCPUSerial());

From 481de45b764747b962f3ec3cf7f98d697881b187 Mon Sep 17 00:00:00 2001
From: Neil Armstrong <narmstrong@baylibre.com>
Date: Tue, 11 Sep 2018 09:34:59 +0000
Subject: [PATCH 2/3] utils: SystemInfo: Use sysfs-devices-soc on Linux if
 available

New Linux embedded systems uses the new sysfs soc device interface
to store the SoC family, id and revision and the board model.

Use this for the Kodi SystemInfo.

Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
---
 xbmc/utils/SystemInfo.cpp | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/xbmc/utils/SystemInfo.cpp b/xbmc/utils/SystemInfo.cpp
index 4eb995528f7d..429cf7ff3c73 100644
--- a/xbmc/utils/SystemInfo.cpp
+++ b/xbmc/utils/SystemInfo.cpp
@@ -27,6 +27,7 @@
 #include "settings/Settings.h"
 #include "platform/Filesystem.h"
 #include "utils/log.h"
+#include "utils/SysfsUtils.h"
 
 #ifdef TARGET_WINDOWS
 #include "dwmapi.h"
@@ -769,6 +770,20 @@ std::string CSysInfo::GetManufacturerName(void)
     auto eas = EasClientDeviceInformation();
     auto manufacturer = eas.SystemManufacturer();
     g_charsetConverter.wToUTF8(std::wstring(manufacturer.c_str()), manufName);
+#elif defined(TARGET_LINUX)
+    if (SysfsUtils::Has("/sys/bus/soc/devices/soc0/family"))
+    {
+      std::string family;
+      SysfsUtils::GetString("/sys/bus/soc/devices/soc0/family", family);
+      if (SysfsUtils::Has("/sys/bus/soc/devices/soc0/soc_id"))
+      {
+        std::string soc_id;
+        SysfsUtils::GetString("/sys/bus/soc/devices/soc0/soc_id", soc_id);
+        manufName = family + " " + soc_id;
+      }
+      else
+        manufName = family;
+    }
 #elif defined(TARGET_WINDOWS)
     // We just don't care, might be useful on embedded
 #endif
@@ -802,6 +817,9 @@ std::string CSysInfo::GetModelName(void)
     auto eas = EasClientDeviceInformation();
     auto manufacturer = eas.SystemProductName();
     g_charsetConverter.wToUTF8(std::wstring(manufacturer.c_str()), modelName);
+#elif defined(TARGET_LINUX)
+    if (SysfsUtils::Has("/sys/bus/soc/devices/soc0/machine"))
+      SysfsUtils::GetString("/sys/bus/soc/devices/soc0/machine", modelName);
 #elif defined(TARGET_WINDOWS)
     // We just don't care, might be useful on embedded
 #endif

From c14da21e19c659cd61381e4c371f8fb518a8aeec Mon Sep 17 00:00:00 2001
From: Neil Armstrong <narmstrong@baylibre.com>
Date: Tue, 11 Sep 2018 13:22:13 +0000
Subject: [PATCH 3/3] utils: CPUInfo: use sysfs-devices-soc to gather more
 system info

New Linux embedded systems uses the new sysfs soc device interface
to store the SoC family, id and the board model.

Use this for the Kodi CPUInfo.

Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
---
 xbmc/utils/CPUInfo.cpp | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/xbmc/utils/CPUInfo.cpp b/xbmc/utils/CPUInfo.cpp
index 24cf8a5e70d3..5b72c89a71dd 100644
--- a/xbmc/utils/CPUInfo.cpp
+++ b/xbmc/utils/CPUInfo.cpp
@@ -10,6 +10,7 @@
 
 #include "CPUInfo.h"
 #include "utils/log.h"
+#include "utils/SysfsUtils.h"
 #include "utils/Temperature.h"
 #include <string>
 #include <string.h>
@@ -419,6 +420,21 @@ CCPUInfo::CCPUInfo(void)
       }
     }
     fclose(fCPUInfo);
+    // new socs use the sysfs soc interface to describe the hardware
+    if (SysfsUtils::Has("/sys/bus/soc/devices/soc0"))
+    {
+      std::string machine, family, soc_id;
+      if (SysfsUtils::Has("/sys/bus/soc/devices/soc0/machine"))
+        SysfsUtils::GetString("/sys/bus/soc/devices/soc0/machine", machine);
+      if (SysfsUtils::Has("/sys/bus/soc/devices/soc0/family"))
+        SysfsUtils::GetString("/sys/bus/soc/devices/soc0/family", family);
+      if (SysfsUtils::Has("/sys/bus/soc/devices/soc0/soc_id"))
+        SysfsUtils::GetString("/sys/bus/soc/devices/soc0/soc_id", soc_id);
+      if (m_cpuHardware.empty() && !machine.empty())
+        m_cpuHardware = machine;
+      if (!family.empty() && !soc_id.empty())
+        m_cpuSoC = family + " " + soc_id;
+    }
     //  /proc/cpuinfo is not reliable on some Android platforms
     //  At least we should get the correct cpu count for multithreaded decoding
 #if defined(TARGET_ANDROID)
